<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>contraste de normalidad: UPDATE PYSCRIPT LATEST</title>
        <link rel="stylesheet" type="text/css" href="style2.css">
        <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
        <script defer src="https://pyscript.net/latest/pyscript.js"></script>
    </head>

    <body>
    <py-config>
        packages = ["pandas", "matplotlib", "statsmodels"] 
    </py-config>

    <div id="archivo" data-tooltip="Se admiten archivos CSV con separación por coma. Primera fila, son los nombres de variables entre comillas. 
    El resto de fila deben ser valores de variables ordenadas en columnas ">
    <input type="file" id="myfile" name="myfile" class="boton2"></div> <!-- aquí se ubica el archivo -->
    <br />
    <div id="print_output"> <!-- aquí se imprime pyscript -->
	    
        <!-- aquí se imprimen primeras líneas de archivo -->
        <p>Contenido de archivo:</p>
        <div class="capa1">
            <div id="content"></div>  
            <div id="content0"></div>
            <div id="content1"></div>
            <div id="content2"></div>
            <div id="content3"></div>
            <div id="content4"></div>
            <div id="content5"></div>
        </div>
        <br />

        <!-- botones de cálculos principales (media y varianza) -->
        <input type="number" class="tentacles" id="tentacles" name="tentacles" min="1" style="width: 30px" value = "1">
        <button py-click="media_aritm()" class="boton1" id="manual" data-tooltip="Elige entes la columna de la base de datos para el cálculo de media">MEDIA</button>
        <button py-click="varianza_aritm()" class="boton1" id="manual2" data-tooltip="Elige columna para el cálculo de varianza">VARIANZA</button>
        <button py-click="min_max()" class="boton1" id="manual3" data-tooltip="Elige columna para el cálculo de mínimo y máximo">MIN&MAX</button>
        
        <!-- usamos id para vincular este boton con script -->


        <!-- en este div se imprimen los cálculos principales (media, varianza etc) -->
        <p>Datos básicos:</p>
        <div class="capa2">
            <div id="dato1"></div>  
            <div id="dato2"></div> 
            <div id="dato3"></div> 
        </div>

        <br />
        <!-- botones para cálculo de gráfica de barras -->
        <input type="number" class="tentacles" id="tentacles_graf1" name="tentacles2" min="1" style="width: 30px" value = "1">

        <button py-click="frecuencia()" class="boton1" id="manual2" data-tooltip="Abajo aparece histograma de datos">FRECUENCIA</button>

        <!-- checkbox para decidir hacer frecuencia relativa -->
        <input type="checkbox" id ="frec_abs_rel" name="frec_abs_rel"> Frecuencia relativa 

        
        <button py-click="borrar()" class="boton1" id="manual2" data-tooltip="borrar todas las gráficas">BORRAR</button></br>
        <input type="number" class="tentacles" id="tentacles_graf2" name="tentacles3" min="0" style="width: 30px" value = "0"> introduzca número de intervalos re representación
        (0 corresponde a represenación por defecto)

        <p>Representación gráfica:</p>

        <!-- aquí se imprime la histograma -->
        <div class="capa3">    
            <div id="mpl2"></div>
        </div>
        
        <!-- detalles de la histograma -->
        <p>Detalles de la histograma</p>
        <div class="capa4">    
            <div id="info_hist_1"></div>
            <div id="info_hist_2"></div>

            <!-- estos dos de abajo aun no estan con nada -->
            <div id="qq_test"></div>
            <div id="graficaerror" data-tooltip="qqtest para comprobar normalidad"></div>
        </div>

    </div>

    <py-script>
# importamos librerias 
import io
import asyncio
import pandas as pd
import matplotlib.pyplot as plt
import math
import numpy as np 
from statsmodels.graphics.gofplots import qqplot # para qq test
import statsmodels.api as sm



from js import document, FileReader
from pyodide.ffi import create_proxy

################################### las funciones que se llaman aparte cada una tras cargar los datos pulsando botones
def media_aritm():
    val = int(document.getElementById("tentacles").value) -1; # restamos unidad para interpretarlo según normativas python
    manual_div0 = Element("dato1") # indicamos donde lo vamos a representar
    media = df.iloc[:,val].mean()
    manual_div0.element.innerText = "media de variable " + str(df.columns[int(val)])+ " es " + str(media.round(4));
def varianza_aritm():
    val = document.getElementById("tentacles").value
    manual_div0 = Element("dato2")
    varianza = df.iloc[:,int(val)-1].var()
    manual_div0.element.innerText = "varianza de variable " + str(df.columns[int(val)-1])+ " es " + str(varianza.round(4));
def min_max():
    val = document.getElementById("tentacles").value
    manual_div0 = Element("dato3")
    minimal = min(df.iloc[:,int(val)-1])
    maximal = max(df.iloc[:,int(val)-1])
    manual_div0.element.innerText = "valor mínimo y máximo de variable " + str(df.columns[int(val)-1])+ " es " + str(minimal) + " y " + str(maximal);


### cálculo de histograma
def frecuencia():
    # en cuantos intervalos dividir la muestra
    intervalos = int(document.getElementById("tentacles_graf2").value); 

    manual_div = Element("mpl2") # gráficas
    manual_div2 = Element("info_hist_1")
    manual_div3 = Element("info_hist_2")
    manual_div4 = Element("qq_test")
    ### los vaciados "" abajo se hacen para limpiar contenido cada vez que se llama nueva gráfica
    manual_div.element.innerText = " ";
    manual_div2.element.innerText = " ";
    manual_div3.element.innerText = " ";
    manual_div4.element.innerText = " ";
    
    val = int(document.getElementById("tentacles_graf1").value) -1;    
    var_x = list(df.iloc[:,val])

    conj = set(var_x)
    x_sorted = sorted(var_x) # lista ordenada
    x_set_sorted = sorted(list(set(var_x))) # conjunto (sin repiticiones) ordenado # paso a lista porque "set no lo es"
    
    freq_s = [x_sorted.count(valor) for valor in x_set_sorted] # frecuencia correspondiente al conjunto x_set_sorted ordenado


    len_conj = len(conj)


    # por defecto si intervalos = 0 se refiere a def freq_abs
    if intervalos == 0:
        intervalos = len_conj
       
    # control de checkbox para hacer frecuencia relativa
    ch = document.getElementById("frec_abs_rel").checked; 
    if ch:
        d = True
    else:
        d = False

    ############# graficas 
    fig, ax = plt.subplots()

    n, bins, patches = ax.hist(var_x, intervalos, density=d)

    ############ gráfica asociada de la función normal.
    media = (np.array(var_x)).mean()
    varianza = (np.array(var_x)).var() 
    y = (1/(np.sqrt(2*np.pi*varianza)))*np.exp((-0.5*(bins-media)**2)/varianza)
    ax.plot(bins, y, '--')
    
    x_sorted=()
    



    
    manual_div2.element.innerText = "conjunto ordenado", x_set_sorted;
    manual_div3.element.innerText = "frecuencia absoluta correspondiente", freq_s;



    plt.xlabel(str(df.columns[val]))
    plt.ylabel(str("frecuencia"))
    plt.title(' ')
    plt.legend(["normalidad", "Frecuencia"])

    fig.set_size_inches(5.5, 5.5)
    display(fig, target="mpl2")    

    ############# graficas de qq test
    
    #qq = qqplot(np.array(var_x) , line='s')
    #display(qq, target="qq_test")
    figure = sm.ProbPlot(np.array(var_x), fit=True)
    qq = figure.qqplot(marker='o', markerfacecolor='blue', markeredgecolor='blue', alpha=0.6)
    qq.set_size_inches(5.5, 5.5)
    sm.qqline(qq.axes[0], line='45', fmt='k--')
    display(qq, target="qq_test")

# borrar todas las gráficas
def borrar():
    manual_div = Element("mpl2")
    manual_div.element.innerText = " "; # limpiar cada vez despues de representar nueva gráfica
    manual_div2 = Element("info_hist_1")
    manual_div2.element.innerText = " ";
    manual_div3 = Element("info_hist_2")
    manual_div3.element.innerText = " ";
    manual_div4 = Element("graficaerror")
    manual_div4.element.innerText = " ";
    manual_div5 = Element("qq_test")
    manual_div5.element.innerText = " ";






### ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
### ///////////////////////////// el código de abajo carga el archivo desde boton (1), define variables a partir de este (3),
### además representa parte de archivo en div content y define variables globales (4),
### el resto de código (superior) funciona ya correctamente con estas variables 

###  2.  procesado de archivo
async def process_file(event):
    fileList = event.target.files.to_py()

    ###  4. esta función se ejecuta automáticamente al cargar el archivo (en boocle de abajo)
    ### solo representa por pantalla rsumen del archivo
    ### y define variables globales para el resto del código
    def representar(dataframe):
        nombres_1 = dataframe.columns.values
        nombres_2 = str(nombres_1)
        document.getElementById("content").innerHTML = nombres_2 # también puede usarse innerHTML o innerText

        # ahora de una vez se guarda esta variable global para poder usarla en todo el script
        global df; 
        df = dataframe;
        global tamanio;
        tamanio = len(dataframe)
        minimal = min(tamanio,4) # para decidir lineas máximo a representar 
        # se imrime en ventana principal (capa 1)
        for x in range(minimal):
            document.getElementById("content" + str(x)).innerHTML = list(dataframe.iloc[x])
        document.getElementById("content5").innerHTML = "... ... tamaño total: " + str(tamanio)

    ###  3. definimos variable df (no global de momento) a partir del texto 
    ### y llamamos función para representar (que también define variables flobales)
    for f in fileList:
        data = await f.text()
        # read_csv recibe como parámetro archivo de texto pero en este caso le pasamos simple contenido del archivo
        # para que read_csv pueda recibir este formato hay que añadir io.stringIO función creada para esto
        df_0 = pd.read_csv(io.StringIO(data)) 

        # representar parte de archivo en un div
        representar(df_0)

###  1. inicia aquí. Se carga desde el botón "myfile"
def main():
    # Create a Python proxy for the callback function
    # process_file() is your function to process events from FileReader
    file_event = create_proxy(process_file)

    # Set the listener to the callback
    e = document.getElementById("myfile")
    e.addEventListener("change", file_event, False)
main()

    </py-script>
    </body>
</html>